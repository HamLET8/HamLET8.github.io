---
title: ELF_Loader
author: ian
date: 2024-08-018 10:15:00 +0800
categories: [Blogging, Linux]
tags: [System]
render_with_liquid: false
---
## 0. 前置知识

C/C++ 程序的编译过程可以被分解为几个阶段，包括预处理、编译、汇编和链接。下面是详细步骤：

1. **预处理（Preprocessing）**：这是编译过程的第一步，处理源代码文件中的预处理指令，如 `#include`、`#define` 和 `#ifdef` 等。预处理器将 `#include` 指令指向的头文件内容直接插入到源文件中，处理 `#define` 定义的宏，以及处理条件编译指令（如 `#ifdef` 和 `#endif`）。预处理器还会删除注释。
2. **编译（Compilation）**：在这个阶段，编译器将预处理后的源代码转换成汇编语言（ \*.S ）。编译器在这个过程中进行语法和语义分析，如果源代码中存在任何错误，都会在这个阶段被检测出来。
3. **汇编（Assembly）**：汇编器 as 将编译器生成的汇编代码转换成机器代码，输出的结果是 **目标文件**（通常是 `.o` 文件）。目标文件包含了程序的机器语言代码以及符号表，后者包含了程序中定义和引用的所有符号（如函数和变量）的信息。
4. **链接（Linking）**：静态链接器 ld 将一个或多个目标文件和库链接在一起生成一个可执行文件。在链接过程中，链接器进行 `<font color=#FF0212>`对使用到的静态库符号和其他文件的符号进行重定位 `</font>`解决符号引用，将对函数和变量的引用链接到其定义的位置。

但是静态链接器 ld 如何处理一个动态库符号呢? 例如 main 函数调用 foo 函数, ld 如何区分这个符号定义在静态库还是动态库亦或者是其他文件中?
为此, 在编译时我们需要传入需要使用的动态库作为参数, 静态链接器会读取动态库的符号表, 如果确定这个函数符号定义于动态库,则最终生成的可执行文件的 symtab section 内, 这个符号会被标记为 dynamic ,留给动态链接器进行重定位.

动态链接的基本思想是把程序按照模块拆分成各个相对独立部分,在程序运行时才将它们链接在一起形成一个完整的程序,而不是像静态链接一样把所有的程序模块都链接成一个单独的可执行文件。

区分: **静态链接是在编译时重定位, 动态链接是在装载时重定位**

动态链接又分为两种形式, 一是初始化时进行链接和装载, 即在程序被首次加载到内存时,完成动态库的加载和链接,由动态链接器完成; 二是显示运行时链接并加载, 也就是由可执行程序在运行时调用库函数 dlopen 来加载指定的共享库, 由 dlsym 取得符号的地址,最后使用 dlclose 完成对共享库的卸载(具体实现参考程序员的自我修养 7.7).

## 1. ELF 文件格式简介

ELF（可执行和可链接格式）是一种常用的二进制文件格式，用于存储程序或其他类型的代码。例如，可执行程序（如 a.out , 以前的 a.out 是类 Unix 系统中的一种早期二进制格式,但由于历史原因,现在默认是 ELF 格式），目标文件（如 a.o），动态库文件（如 a.so）都是采用 ELF 格式。

ELF 文件包含多个 section，例如 `.text`（存储代码）、`.data`（存储已初始化的全局变量和静态变量）、`.bss`（存储未初始化的全局变量和静态变量）、`.rodata`（存储只读数据，如常量）、`.symtab`（存储符号表）、`.strtab`（存储字符串表）、`.rel.text`（存储重定位信息）等。

当程序需要被映射到内存中时，ELF 为了避免内存碎片，会将权限相同的 section 合并为一个 segment。例如，`.text` 和 `.rodata` sections 可能会合并为一个只读的 segment，而 `.data` 和 `.bss` sections 可能会合并为一个可读写的 segment( .bss 由程序头表项的 p_filesz 和 p_memsz 决定)。这些 segments 由程序头表（Program Header Table）描述。

每个 segment 被内核分配一个虚拟内存地址空间区域（Virtual Memory Area，VMA）。VMA 是一个连续的虚拟内存地址范围，具有相同的访问权限（读、写、执行）。内核会确保每个 segment 在内存中的位置满足其对齐要求，并且具有正确的访问权限。堆和栈也是通过 VMA 来管理.

## 2. ELF 文件装载

当 shell 收到可执行文件时, 首先通过 fork 系统调用创建一个子进程, 然后使用 execve 系统调用来执行可执行文件.

execve 会进入内核 执行 sys_execve 进行参数检查, 然后通过 do_execve 来完成可执行文件的解释和加载.
首先通过检查文件开头的 magic number 来识别对应的文件格式, 如果过是 ELF 则调用 load_elf_binary 完成可执行文件的装载, 如果是 a.out 格式则执行 load_aout_binary.
load_elf_binary 函数的功能如下(参考程序员的自我修养 p174):

* (1)查 ELF 可执行文格式的有效性，比如 magic number、头表中段 (Sgment)的数量
* (2)寻找动态链接的“intep”段(动态链接器的软连接),设置动态链接器路径。
* (3)根据 ELF 可执行文件的程序头表的描述，对 ELF 文件进行映射，比如可读执行段, 只读数据段, 可读可写段。
* (4)初始化 ELF 进程环境。
* (5)将 execve 系统调用的返回地址修改成 ELF 可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的 ELF 可执行文件，这个程序入口就是 ELF 文件的文件头中 e_entry 所指的地址, 可以 -e 指定; 对于动态链接的 ELF 可执行文件，程序入口点是 **动态链接器 dl_start()** 。

## 3. 动态链接器

musl 没有单独的动态链接器, 是把动态链接器写进了 libc.so 中. 而在 glibc 中是单独分开的, 一个是 libc.so, ld.so。

动态链接器本身也是一个共享对象,而且是静态链接的。
动态链接器本身是静态链接, 因为它不依赖与其他共享库, 但他作为共享库供其他模块链接.

glic 的 ld.so 可以使用 ldd 指令单独执行, 但是本身是一段 shell 脚本

<font color=#FF0212>
WARNING: 下文中大部分都是参考 glibc ld.so 机制, musl 链接机制后续有了更深理解会更新.</font>

### 3.1 musl 的链接器

下面是 libc.so 的 ELF Segment 格局, 可以看出 0 号段内的 section 包含只读的动态符号表,重定位信息和为了快速查找符号的哈希表; 1 号段是可读可执行的 code 和 plt (Procedure Linkage Table); 2 号段为只读数据, 3 号段包含需要可读写的数据和 GOT(Global Offset Table)表,其余段不被加载.

下图为可执行程序 a.out 的内存运行布局, 根据地址段的读写权限可以跟上图 `<font color=#FF0212>`不 `</font>`一一对应: (为了避免内存碎片, 采用了段对齐: 程序员的自我修养 P169)

### 3.2 PIC 与 GOT

使用 gcc -fPIC 即可产生位置无关的代码(PIC, Position Independent Code), PIC 与绝对地址无关,在模块内部以当前 PC 指针或者模块基址的偏移替代符号地址.

GOT(全局偏移表) 是 ELF 中可读写区域的 section, 记录模块内部使用的符号以及对应地址, 可执行程序与共享对象都有独立的 GOT.

在程序中, 如果一个模块访问模块外部的数据或者函数, 必须知道它的地址. 但是动态库只有在运行时才被加载, 所以模块内部的变量及函数符号的地址是不确定的,而代码段的权限是只读的, 动态链接器无法修改代码段来重定位, 因此它是通过间接的方式来对符号进行重定位, 静态链接器在链接阶段将使用到的外部符号指向 GOT 中的地址。

动态库模块内部使用位置无关代码, 即代码中变量和函数的地址都是相对地址, 即相对模块基址的地址, 并将信息填入到符号表中, 当模块被加载时, 动态链接器会将模块符号表信息填充到主程序的 GOT(全局偏移表)中, 主程序通过访问 GOT 的基址和偏移地址来简介获得动态库符号的地址.

也就是说, 模块内部的数据访问使用相对寻址, 而模块内部全局函数和跨模块的访问需要借助 GOT(细节参考程序员的自我修养第 7 章).

### 3.3 链接器需要的信息

ELF 中有多个段专门用于动态链接, 如:

* 1. **.interp**：指定了动态链接器的路径, 字符串类型。
* 2. **.dynsym**：这个段包含了动态符号表, 只保存动态链接相关的符号()。
* 3. **.dynstr**：这个段包含了动态字符串表。
* 4. **.hash** 或 **.gnu.hash**：这些段包含了一个哈希表，用于快速查找动态符号表中的符号。
* 5. **.rel.dyn** 和 **.rel.plt**：这些段包含了重定位表，描述了如何修改程序的代码和数据以解析符号引用。`.rel.dyn` 通常包含了处理非函数符号（比如全局变量）需要的重定位条目，而 `.rel.plt` 则包含了处理函数调用需要的重定位条目()。
* 6. **.got** 和 **.plt**：这些段用于实现函数调用的 "延迟绑定" 或 "懒加载"。`.got`（全局偏移表）包含了运行时需要修改的地址，而 `.plt`（过程链接表）包含了一些桩函数，它们在被调用时会跳转到 `.got` 中指定的地址(参考 7.4)。
* 7. **.dynamic**：这个段包含了一系列的动态链接信息，比如需要的动态库的列表，一系列重定位表如 `.rel` 的地址以及 `DT_INIT` 和 `DT_FINI` 函数的地址等。(成员项 参考 7.5.2)

此外, 在操作系统进入动态链接器前, 会将一些信息压栈, 作为参数传递.
如: 可执行文件(elf_phdr)和进程的信息(e_entry), 环境变量, 操作系统会根据 Elf32_auxv_t {size_t a_type, size_t a_val} 的格式将辅助信息放在栈上, 但是 musl 自己声明一个 size_t aux[MAX_CNT] 来接收这些信息 ,将 ELF 中 Elf32_auxv_t 项的类型 a_type 作为下标, a_val 作为数组中的值( dynv 数组类似). ( Elf32_auxv_t 类型参考 7.5.5 )

````c
for (i=0; i<AUX_CNT; i++) aux[i] = 0;

for (i=0; auxv[i]; i+=2){

    if (auxv[i]<AUX_CNT)

        aux[auxv[i]] = auxv[i+1];

    }
  ```
```c
// 栈指针, .dynamic 段
hidden void _dlstart_c(size_t *sp, size_t *dynv)
````

在没有内核支持下, 我们可以在 \_dlstart_c 中手动把需要的参数压栈, 完成对 sp 的修改，模仿 main 函数传参。

### 3.4. 延迟绑定 (Lazy Binding) 和 PLT

延迟绑定是为了缩短程序的动态重定位时间, 将符号的重定位延迟到第一次使用时, 同时避免重定位大量不会被访问的符号.

ELF 使用 PLT( Procedure Linkage Table) 来实现延迟绑定, 前面介绍过模块间的符号访问需要通过 GOT 来做跳板, 在实现延迟绑定的动态链接中, 程序遇到符号会先跳转到模块内的 PLT 中的代码, 在内存布局中, PLT 和 TEXT 合并为一个可读可执行段, 因为 PLT 中也是可执行代码.
例如当 main 函数调用 动态库中的 bar 时, 会跳转到 bar@plt 执行以下指令(此处为简略版):

第一条指令跳转到 GOT 中重定位的 bar 地址, 但此时并未重定位, 而 \*(bar@GOT) 被初始化为第二条指令也就是 push n 的地址, 因此继续执行, 将 n 和 module 入栈,跳转到 \_dl_runtime_resolve 进行符号重定位, 设置 bar@GOT 中的地址为动态库的地址, 当再次执行 bar 函数时, 只执行第一句指令即可跳转到 bar 函数.

这里有点绕, 可以参考
(1) 程序员的自我修养 P201.(主要参考)
(2) \_dl_runtime_resolve https://www.jianshu.com/p/57f6474fe4c6
(3) Dynamic Linking http://lastweek.io/notes/dynamic_linking/

## 4. 重定位 (待完善)

**Load Time Relocation** 步骤:

**链接器自举 :**
完成自身符号的重定位.
根据操作系统提供的 dynamic 和 aux 辅助信息, 自己根据重定位表对 GOT 进行修改.

**装载 :**
DFS 或者 BFS 装载共享模块, 合并符号表并完成初始化

1. got.plt 模块 ID 和\_dl_runtime_resolve 地址 .
2. got 的初始化, 如将函数所在的 got 项初始化为 plt 第二行指令地址.

**重定位** relloc_all(struct dso\*);

在动态链接器需要对符号进行重定位时, 由于懒加载机制,在调用函数时触发 \_dl_runtime_resolve 函数, \_dl_runtime_resolve 完成对地址的解析, 即获得符号对应的可重定位项(.rel.plt), 符号名字字符串(.dynstr), 调用 \_dl_fixup 完成最终的重定位, 即查找动态库符号表(全局符号表?) 得到符号地址, 并填充到函数符号所在的可重定位项(.rel.plt) (musl 没有这个函数, do_relloc() 机制不同).

参考:

1. 程序员的自我修养 7.5
2. \_dl_runtime_resolve https://www.jianshu.com/p/57f6474fe4c6

**Run-Time Load :**

dlopen 加载一个共享库
dlsym 查找共享库中的符号地址
dlclose 卸载一个共享库
dlerror 判断是否调用成功

(此处有待完善 参考 程序员的自我修养 7.7 )

## 5. 动态库内的符号隐藏

当存在多个动态库和静态库时, 在进行符号绑定时可能会绑定到错误的地址, 如 ax.so 动态库中静态编译了 ex-1.0.a, 应用程序 app 静态链接了 ex-2.0.a 后 , 动态链接了 ax.so, 那么在执行时可能会发生版本不匹配 crash 而且很难发现 bug, 因此应该隐藏不需要暴露给外面的符号, 从而避免符号冲突.

方法一: (编译阶段)
使用 -fvisibility=hidden 隐藏所有符号, 使用**attribute**((visibility("default"))) 来修饰想要暴露的接口, 此方法不能隐藏静态库中的符号.

方法二: (链接阶段)
使用链接脚本
-Wl, --version-script ./sym.ver
{
global: //开放给外部的接口
\*keyword\*;
local: //隐藏所有
\*;
}

参考： https://www.bilibili.com/video/BV1j14y1m7Zw

## 6. 操作系统依赖性

1. musl libc 的动态加载基本不依赖系统调用,
2. 但有一些机制需要 OS 和 c 库的支持, 如 TLS 机制
